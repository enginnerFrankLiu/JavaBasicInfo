to log some temp information.

常量池->
字面量：
字面量就是我们在程序组定义的字符串，被final修饰的值.
符号引用：
符号引用就是我们定义的各种名字：类和接口的全限定名，字段的名字和描述符，方面的名字和描述符;

元数据空间并不存在虚拟空间，而是用本地内存;

是当前线程正在执行的那条指令的地址;
是当前线程正在执行的那条指定的地址；

java 虚拟机栈是与线程对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题;

程序计数器 java虚拟机器栈 本地方法栈都是一个对应的线程对应一个.
堆 区域是：线程共享的；java 中只有一个堆区域，所有的线程访问同一个堆.

已经被虚拟机加载的类信息
常量
静态常量
即时编译后的代码

方法区域
主要回收是对常量池的回收 和对类型的卸载
系统会先创建一个匿名对象"Hello"存入堆内存（我们暂且叫它A)，然后new关键字会在堆内存中又开辟一块新的空间，然后把"Hello"存进去


如果线程正在执行的一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址；

正在执行的虚拟机字节码指令地址;
如果正在执行的是本地方法，那么这个计数器

第一个是概念上的区分:
方法区是jvm规范定义的一个概念，用于存储类信息 常量池 静态变量 JIT编译后的代码数据.
而永久代是Hotpot虚拟机有的一个概念，是方法区的一个体现，别的JVM都没这个东西。


JDK之前，类的元数据和常量都放在一个与堆内存相邻的数据区-永久代；
在Java 8中，永久代被彻底移除，
取而代之的是另一块与堆不相连的本地内存——元空间（Metaspace）,
‑XX:MaxPermSize 参数失去了意义，
取而代之的是-XX:MaxMetaspaceSize


总结出来就两点吧：
1.加载类的数据时，太大了，会出现了OOM
2.GC性能的提高
3.metaspace并不在虚拟机内存中而是使用本地内存.


虚拟机加载的类型
常量池
静态变量
即时编译后的代码


说去说来，他妈的就这两项吧：
减少OOM只是表因
更深层的原因还是要合并HotSpot和JRockit的代码,
JRockit从来没有一个叫永久代的东西但是运行良好
也不需要开发运维人员设置这么一个永久代的大小.
link:
https://www.infoq.cn/article/java-permgen-removed
link:好总结
https://blog.csdn.net/u011635492/article/details/81046174
运行时常量池：方法区的一部分，用于存在编译期间生成的各种字面量和符号引用
在HotSpot上把GC分代收集扩展至方法区
说使用永久代来实现方法区
那么取代永久代的就是元空间


temp:不同对象的hashCode 也可能是相同的：
to do links：
https://www.zhihu.com/question/22739143
https://blog.csdn.net/fly_fly_fly_pig/article/details/82492491
