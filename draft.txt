to log some temp information.

常量池->
字面量：
字面量就是我们在程序组定义的字符串，被final修饰的值.
符号引用：
符号引用就是我们定义的各种名字：类和接口的全限定名，字段的名字和描述符，方面的名字和描述符;

元数据空间并不存在虚拟空间，而是用本地内存;

是当前线程正在执行的那条指令的地址;
是当前线程正在执行的那条指定的地址；

java 虚拟机栈是与线程对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题;

程序计数器 java虚拟机器栈 本地方法栈都是一个对应的线程对应一个.
堆 区域是：线程共享的；java 中只有一个堆区域，所有的线程访问同一个堆.

已经被虚拟机加载的类信息
常量
静态常量
即时编译后的代码

方法区域
主要回收是对常量池的回收 和对类型的卸载
系统会先创建一个匿名对象"Hello"存入堆内存（我们暂且叫它A)，然后new关键字会在堆内存中又开辟一块新的空间，然后把"Hello"存进去


如果线程正在执行的一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址；

正在执行的虚拟机字节码指令地址;
如果正在执行的是本地方法，那么这个计数器

第一个是概念上的区分:
方法区是jvm规范定义的一个概念，用于存储类信息 常量池 静态变量 JIT编译后的代码数据.
而永久代是Hotpot虚拟机有的一个概念，是方法区的一个体现，别的JVM都没这个东西。


JDK之前，类的元数据和常量都放在一个与堆内存相邻的数据区-永久代；
在Java 8中，永久代被彻底移除，
取而代之的是另一块与堆不相连的本地内存——元空间（Metaspace）,
‑XX:MaxPermSize 参数失去了意义，
取而代之的是-XX:MaxMetaspaceSize


总结出来就两点吧：
1.加载类的数据时，太大了，会出现了OOM
2.GC性能的提高
3.metaspace并不在虚拟机内存中而是使用本地内存.


虚拟机加载的类型
常量池
静态变量
即时编译后的代码


说去说来，他妈的就这两项吧：
减少OOM只是表因
更深层的原因还是要合并HotSpot和JRockit的代码,
JRockit从来没有一个叫永久代的东西但是运行良好
也不需要开发运维人员设置这么一个永久代的大小.
link:
https://www.infoq.cn/article/java-permgen-removed
link:好总结
https://blog.csdn.net/u011635492/article/details/81046174
运行时常量池：方法区的一部分，用于存在编译期间生成的各种字面量和符号引用
在HotSpot上把GC分代收集扩展至方法区
说使用永久代来实现方法区
那么取代永久代的就是元空间


temp:不同对象的hashCode 也可能是相同的：
to do links：
https://www.zhihu.com/question/22739143
https://blog.csdn.net/fly_fly_fly_pig/article/details/82492491

自律
每天抽出两个小时学习

class 文件中的常量池：

class 文件中常量次指的是编译生成的class 字节码文件；
其结构有一项常量池（constant pool table）
用于存放编译期间生成的各种字面量和符号引用,这部分内容将在类加载进入方法区的
运行时常量池


字面量：这里的字面量是指字符串字面量和申明为final常量的常量值；
这些字符串字面量除了了中所有用双引号括起来的字符串（包括方法体）
还包括
所有用到的类名，方法的名字和这些类与方面的字符串描述，字段（成员变量）的名称和描述符
这些都在常量池的UTF-8的表中

符号引用 直接引用
只不过是以一组符号来描述所引用的目标，和实际的内存无关，所以称为符号引用
直接指向内存中的某一个地址的引用-> 直接引用

运行时常量池是方法去的一部分，是一块内存区域
class文件中的常量池将在类加载后进入方法去的运行时常量池中存放。

一个类加载到jvm中后对应一个运行时常量池
一个类加载到jvm中后对应一个运行时常量池;
一个类加载到jvm中后对应一个运行时常量池;

可以说运行时常量池就是用来所以和查找字段和方法名称和描述符号的；
给定任意一个方法或字段的索引，通过这个索引最终可得到该方法或字段所属的类信息和名称以及描述信息；
这涉及到方法和调用和字段的获取

参看常量池中中是否存在这个字符串对象的引用，若有就直接返回这个引用地址，若没有，就在堆里创建这个字符串对应
并在字符串常量池中记录下这个引用(jdk.1.7)
String 类的intern方法还可以在运行期间把字符串放到字符串常量池中。
这里值得注意的是：
java内存模型
java内存结构（运行时数据区域）
java class loader



why string type designed as immutable
1.save memory
2.thread safe (sync)
3.security
4.hashcode cache

保证好习惯：
每天两小时的“有效”学习时间的保证.

字面量
符号引用 直接引用
class文件中的常量池
运行时常量池
字符串常量池

how manny objected are created?

那么String s=new String("a"+"b");创建了几次对象?
https://www.jb51.net/article/186259.htm
如何去理解题中的不可变.


其中：虚拟机 本地方法栈以及程序计数器都为线程隔离的的，
方法区和堆区都是线程共享的数据区

1.7 已经将常量池逐步的移除方法去了

hotspot虚拟机中永久代和堆虽然相互隔离，但 他们物理内存是连续的，而且老年代和永久代的垃圾收集是捆绑的
无论谁满了，都会触发永久带和老年的GC回收.


元空间在1.8 中不在于堆似乎连续的物理内存 而 是改为本地物理内存;
元空间使用本地内存也就意味着本地内存


一个类加载到jvm后中对应一个运行时常量池.
一个类加载到jvm后对应一个运行时常量池.
一个类加载到jvm后对应一个运行时常量池.

运行时常量池中的字符串字面量若是成员的，则再类加载初始化的阶段就是用到了字符串常量池，若是本地的，
则再使用到的时候（执行代码时）才会使用到字符串常量池，

“使用常量池” 使用ldc指令；

8中基本数据类型中除了两种浮点类型 剩余6中基本数据类型的包装类，都在使用缓冲池技术；
但是 Byte、Short、Integer、Long、Character 这5种整型的包装类也只是在对应值在 [-128,127] 时才会使用缓冲池，超出此范围仍然会去创建新的对象。其中：



no time for learn programming skill,because i am tired and not happy about my life.
I lost my most relative.I lost it. i will live and fight lonely.
finally I spend some some practicing my listen and wash my clothes.
fine.
keep going and moving.
some good thing will happen in some day.
some good person I will meet in some day.



Eden区被划分为
多个线程本地分配缓冲区
多个线程本地分布缓冲区
多个线程本地分布缓冲区

今天的目标又没有完成，感觉心累啊.


明天的target:
年起代的一些具体细节?
一个类加载到 JVM 中后对应一个运行时常量池？
用空再看看:
https://www.infoq.cn/article/java-permgen-removed


新生代的特点：很多对象创建->使用后，就会变成垃圾 存活对象少，垃圾多，-标记-复制
老年代特点：经历过多次YGC后依然存活下来的对象，存活对象多，垃圾少
永久代:静态文件

第一个结论就是：
年龄做够的对象才能被放进老年代，年龄做够的意思就是：在经历了多次YGC（minor gc）之后，依然能够存活的对象.
Eden SurvivorA SurvivorB

1.首先，Eden区最大，对外提供堆内存。
当 Eden 区快要满了，则进行 Minor GC，把存活对象放入Survivor A区，清空 Eden 区,Eden区被清空后，继续对外提供堆内存.


2.当Eden区再次被填满，此时对Eden区和Survivor A区同时进行 Minor GC，把存活对象放入Survivor B区，同时清空Eden区和Survivor A区

3.Eden区继续对外提供堆内存，并重复上述过程，即在Eden区填满后，把Eden区和某个Survivor区的存活对象放到另一个Survivor区；

何时将对象从年轻代移动到老年代呢?答案就在这里
当某个Survivor区被填满，且仍有对象未被复制完毕时，或者某些对象在反复Survive 15 次左右时，则把这部分剩余对象放到Old区；
当 Old 区也被填满时，进行 Major GC，对 Old 区进行垃圾回收

JIT编译器是在程序运行期间。将java 字节码编译成平台相关的二进制代码；正因为此编译行为发生在程序运行期间，所以该编译器称之为JUST IN TIME.

今天的任务还没有完成，卧槽:
https://zhuanlan.zhihu.com/p/161994662
https://blog.csdn.net/u011635492/article/details/81046174
target:
1. 画出java 7 8 的内存模型图
2.不同区域的作用
3.线程是否共享
4.本机内存还是jvm进程中占据的内存.



